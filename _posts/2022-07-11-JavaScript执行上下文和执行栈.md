---
layout: post
title: JavaScript执行上下文和执行栈
categories: 
tags: []
---

### 什么是执行上下文
执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行


### 执行上下文分类
* 全局执行上下文  
  不在任何函数中的代码都位于全局执行上下文中。
  1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。
  2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
* 函数执行上下文  
  每次调用函数时，都会为该函数创建一个新的执行上下文
* Eval函数执行上下文

### 执行上下文声明周期
1. 创建阶段  
   发生于：当函数被调用，但未执行任何其内部代码之前  

   执行内容：
   * 创建变量对象：初始化函数的参数arguments，提升函数声明和变量声明  
     **当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。**
   * 创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
   * 确定this指向  
     **this的值是在执行的时候才能确认，定义的时候不能确认** 为什么呢，这是因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候
2. 执行阶段  
   执行变量赋值、代码执行
3. 回收阶段  
   执行上下文出栈等待虚拟机回收执行上下文

   ![JavaScript函数this](../assets/images/javascript%E5%87%BD%E6%95%B0this.webp)


### 执行上下文栈（Execution Context Stack）
每次调用函数都会创建一个新的执行上下文。当函数多了，就会有多个函数执行上下文，而 JavaScript 引擎创建了执行上下文栈来管理执行上下文。  
可以把**执行上下文栈**认为是一个存储函数调用的栈结构，遵循先进后出的原则。例如：
![JavaScript执行上下文和执行栈](../assets/images/JavaScript%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.webp)
* JavaScript执行在单线程上，所有的代码都是排队执行。
* 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
* 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
* 浏览器的JS执行引擎总是访问栈顶的执行上下文。
* 全局上下文只有唯一的一个，它在浏览器关闭时出栈


参见:
1. [深入理解JavaScript执行上下文和执行栈](https://segmentfault.com/a/1190000018550118)
