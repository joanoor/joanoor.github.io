---
layout: post
title: MySQL进阶
categories: 
tags: []
---

## 存储引擎
### MySQL体系结构
![体系结构](../assets/images/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png)
* 连接层  
  最上层的连接层是一些客户端和连接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限
* 服务层  
  第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等
* 引擎层  
  存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎
* 存储层  
  主要是将数据存储在文件系统之上，并完成与存储引擎的交互

### 存储引擎
存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表的类型
```sql
-- 查看当前数据库支持的存储引擎
show engines;

-- 建表时指定存储引擎
create table 表名(
  ...
) engine = 引擎名
```

* InnoDB  
  InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。  
  特点：
  * DML操作遵循ACID模型，支持**事务**；
  * **行级锁**，提高并发访问性能；
  * 支持**外键**foreign key约束，保证数据的完整性和准确性  
  
  文件：  
  xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。  
  参数：  
  innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间  
  InnoDB逻辑存储结构：  
  ![逻辑存储结构](../assets/images/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png)  
  **一个区最大是1M，一页最大是16K**
* MyISAM  
  MyISAM 是 MySQL 早期的默认存储引擎。  
  特点：  
  * 不支持事务，不支持外键
  * 支持表锁，不支持行锁
  * 访问速度快
  
  文件：
  * xxx.sdi: 存储表结构信息
  * xxx.MYD: 存储数据
  * xxx.MYI: 存储索引
* Memory  
  Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。  
  特点：
  * 存放在内存中，速度快
  * hash索引（默认）
  
  文件：
  * xxx.sdi: 存储表结构信息

MySQL主要存储引擎的特点： 
**特点** | **InnoDB** | **MyISAM** | **Memory**
:-----: | :-----: | :-----: | :-----:
存储限制 | 64TB | 有 | 有
事务安全 | 支持 | - | -
锁机制 | 行锁 | 表锁 | 表锁
B+tree索引 | 支持 | 支持 | 支持
Hash索引 | -| - | 支持
全文索引 | 支持（5.6版本之后）| 支持 | -
空间使用 | 高|低 | N/A
内存使用 | 高|低 | 中等
批量插入速度 | 低 | 高 | 高
支持外键 | 支持 | - | -

存储引擎的选择  
在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择  

MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。（一般通过No SQL的数据库，如Mongodb）  

Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性
电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。（一般通过redis）

## 索引
索引是**帮助 MySQL 高效获取数据的数据结构（是一种有序的数据结构）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。  
优点：
* 提高数据检索效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

缺点：
* 索引列也是要占用空间的
* 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE

### 索引数据结构
**索引结构** | **描述**
----- | -----
B+Tree | 最常见的索引类型，大部分引擎都支持B+树索引
Hash | 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，**_不支持范围查询_**
R-Tree(空间索引) | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
Full-Text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES

MySQL的索引是在存储引擎层实现的，不同的存储引擎支持不同的结构：
**索引** | **InnoDB** | **MyISAM** | **Memory**
-----|-----|-----|-----
B+Tree索引 | 支持 | 支持 | 支持
Hash索引 | 不支持 | 不支持 | 支持
R-Tree索引 | 不支持 | 支持 | 不支持
Full-text | 5.6版本后支持 | 支持 | 不支持

* 二叉树
  ![二叉树](../assets/images/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png)  
  缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢

* 红黑树
  二叉树的缺点可以通过红黑树来解决，红黑树是一种自平衡的二叉树
  ![红黑树](../assets/images/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png)  
  缺点：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。

* B-Tree（B树，也叫多路平衡查找树）  
  以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）  
  ![B树](../assets/images/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png)  
  备注：数的度数指的是一个节点的子节点的个数（也就是每个节点的最大指针个数）

* B+Tree（B加树，是对B树的优化）
  ![B+树](../assets/images/B%2BTree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png)
  备注：
  * 所有的数据都会出现在叶子节点
  * 叶子节点形成一个单向链表

* MySQL InnoDB索引的数据结构  
  MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。
  ![MySQL索引数据结构](../assets/images/mysql_B%2B%E6%A0%91_%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png)

* MySQL hash索引的数据结构  
  哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。  
  如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。
  ![hash索引](../assets/images/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png)
  特点：
  * Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、>、<、…）
  * 无法利用索引完成排序操作
  * 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引
  
  在MySQL中，支持hash索引的是Memory引擎，而InnoDB具有自适应hash功能，hash所有是存储引擎根据B+tree索引在指定条件下自动构建的

总结：  
为什么InnoDB存储引擎选择使用B+tree索引数据结构？
  * 相对于二叉树，层级更少，搜索效率高
  * 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
  * 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作

### 索引分类
**分类** | **含义** | **特点** | **关键字**
----- | ----- | ----- | -----
主键索引 | 针对于表中主键创建的索引 | 默认自动创建，一张表中只能有一个 | PRIMARY
唯一索引 | 避免同一个表中某数据列中的值重复 | 一张表中可以有多个 | UNIQUE
常规索引 | 快速定位特定数据 | 一张表中可以有多个 | 
全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 一张表中可以有多个 | FULLTEXT

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：
**分类** | **含义** | **特点**
----- | ----- | -----
聚集索引(Clustered Index) | 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个
二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个

聚集索引的选取规则：
* 如果存在主键，主键索引就是聚集索引
* 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引
* 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引

![索引分类](../assets/images/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB_%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png)

**回表查询**：先走二级索引查找对应的聚集索引值，在根据聚集索引值再到聚集索引中拿到行数据

总结：  
InnoDB 主键索引的 B+Tree 高度为多少？  
假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.  
可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。  
如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；  
如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。

### 索引操作语法
```sql
-- 创建索引
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);

-- 查看索引
SHOW INDEX FROM table_name;

-- 删除索引
DROP INDEX index_name ON table_name;
```

### SQL性能分析
* SQL执行频率（查看当前数据库增删改查这四种操作哪种占比比较高）
  ```sql
  show [global|session] status like 'Com_______';
  ```

* 慢查询日志  
  慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。  
  MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：
  ```sh
  # 开启慢查询日志开关
  slow_query_log=1
  # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
  long_query_time=2
  ```
  查看慢查询日志开关状态：```show variables like 'slow_query_log';```

* profile详情  
  在做SQL优化时帮我们了解时间都耗费在哪里。
  ```sql
  -- 查看当前MySQL是否支持profile操作
  select @@have_profiling;

  -- 可以看到MySQL是支持profile操作的，但是该功能默认是关闭的，可以通过下面语句开启profiling
  set profiling = 1

  -- 查询所有语句的耗时
  show profiles;

  -- 查看指定query_id的SQL语句各个阶段的耗时
  show profile for query query_id;

  -- 查看指定query_id的SQL语句CPU的使用情况
  show profile cpu for query query_id;
  ```

* explain操作  
  explain 或者 desc 命令获取 MySQL 如何执行 select 语句的信息，包括在 select 语句执行过程中表如何连接和连接的顺序
  ```sql
  -- 直接在select语句之前加上关键字 explain / desc
  explain select 字段列表 from 表名 where 条件;
  ```
  explain结果各字段含义：
  * id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）
  * select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等
  * type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all（all表示没有索引，全表扫描）
  * possible_key：可能应用在这张表上的索引，一个或多个
  * Key：实际使用的索引，如果为 NULL，则没有使用索引
  * Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
  * rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的
  * filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好

### 索引使用规则


## 视图/存储过程/触发器


## 锁


## InnoDB引擎


## MySQL管理

