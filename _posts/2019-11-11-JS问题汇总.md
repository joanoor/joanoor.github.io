---
layout: post
title: 问题汇集
categories: 前端
tags: [Javascript]
---
### js 赋值语句有返回值，返回的是等号右边的值！
![js赋值语句返回值](../assets/images/js%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC.png)

### var和let const的区别
什么是作用域？  
本质上是指变量/函数可供访问的范围

区别  
1. 在ES6出现之前，必须使用 var 声明。**var声明的变量只有函数作用域和全局作用域，没有块级作用域。** 
2. var变量可以重新声明和修改
3. var声明的变量，会发生变量提升，但是只是**声明提升，赋值不会提升**
4. let和const属于块级作用域，它们声明的变量只在当前作用域中有效，且没有像var那样的变量提升（称为暂时死区,tdz: temporal dead zone）
5. let声明的变量可以修改，但不能重复声明；const声明的变量相当于常量，不能被修改并且不能被重新声明。（虽然const变量不能修改指针，但是可以修改值，比如我们定义一个对象，我们就可以修改对象里的属性值，但是不可以重写整个对象。）
  
*  
参见:
1. [var、let、const三者区别](https://juejin.cn/post/6925641096152399880)
2. [JavaScript 中的 Var、Let 和 Const 有什么区别](https://chinese.freecodecamp.org/news/javascript-var-let-and-const/)
3. [现代 JavaScript 教程](https://zh.javascript.info/)


### Function.prototype.bind()
bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
**返回值是一个新函数**

### 箭头函数可以通过bind/call/apply来修改this指向吗？
不可以。因为箭头函数不是在调用的时候决定this，而是在箭头函数 申明 的时候，就指定了this，指向上层 父作用域 的this，如果父作用域没有this，则依次往上
![箭头函数this指向](../assets/images/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91.png)

### Object.assign(target,source)
是将所有可枚举属性从一个或多个源对象分配到目标对象，将返回目标对象。  
所以最好Object.assign的第一个参数为{}

### JSON.parse(JSON.stringify())
只能序列化对象的普通属性，对象的方法无法被序列化

### 当项目中使用Swiper.js的时候，注意如果要适配IE浏览器，选择使用Swiper3.X或者Swiper2.X，因为较新版本的Swiper.js不支持IE

### node-sass报错python环境：设置sass_binary_site指向淘宝镜像地址
```npm i node-sass --sass_binary_site=https//npm.taobal.org/mirrors/node-sass```
重新安装node-sass

### 当使用Jquery来判断是否是IE浏览器时报错：Uncaught TypeError: Cannot read property 'msie' of undefined  
这是因为$.browser方法从jquery1.9中移除，可以通过下面的方式来判断：
```
navigator.userAgent.match(/MSIE ([0-9]+)\./)
// 当返回是null的时候，表示不是IE浏览器（IE11的话，返回也是null）
```

### 存在三个函数A,B,C，其中C中调用B，B中调用A，如果A中抛出错误，则在C中可以直接捕获（不需要在B中捕获抛出）

###  UTF-8中一个中文字符是三个字节

### 浏览器如何识别地址栏是网页地址还是get请求？

### xxxxxStorage.getItem(xxx) 如果xxx对应的value获取不到，那么getItem的返回值是null。JSON.parse(null)仍然是null

### sessionStorage存储的数据在关闭浏览器之后会被清除

### 后置自增x++，操作数会加1，然后返回加1之前的值；前置自增++x，操作数会加1，然后返回加1之后的值


